# -*- coding: utf-8 -*-
"""reorder_to_align_w_orig_and_sum_thermos_as_well.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XfQcOVJPK4FWMECl_FAfPhMQDkwOpvTR
"""

import pandas as pd
from collections import defaultdict, deque

def align_csv_by_key(csvA, csvB, output_csv):
    """
    Reads two CSVs, A and B, identifies matching rows based on columns A..J,
    and reorders rows in B to match the order in A. Writes the result to 'output_csv'.
    """
    # Read CSVs into DataFrames
    dfA = pd.read_csv(csvA)
    dfB = pd.read_csv(csvB)

    # Define the columns used to match rows (A..J).
    # Adjust these to match your actual CSV headers or indices.
    matching_cols = dfA.columns[:10]  # e.g. first 10 columns

    # Create a composite key (tuple) for matching in both A and B
    dfA['match_key'] = dfA[matching_cols].apply(tuple, axis=1)
    dfB['match_key'] = dfB[matching_cols].apply(tuple, axis=1)

    # Build a dict of match_key -> queue of row indices in B
    b_index_map = defaultdict(deque)
    for idx, row in dfB.iterrows():
        key = row['match_key']
        b_index_map[key].append(idx)

    # Prepare a new DataFrame to hold B's rows in the new order
    newB = pd.DataFrame(columns=dfB.columns)

    # Iterate over rows in A in correct order, "pull" from b_index_map
    for a_idx, a_row in dfA.iterrows():
        key = a_row['match_key']
        b_idx = b_index_map[key].popleft()
        # Copy that row from dfB into newB at the same index as in A
        newB.loc[a_idx] = dfB.loc[b_idx]

    # (Optional) Drop the temporary 'match_key' column
    newB.drop(columns=['match_key'], inplace=True)

    # Write the newly ordered DataFrame B to CSV
    newB.to_csv(output_csv, index=False)


def fill_gm_hm_columns(input_csv, output_csv):
    """
    Reads a CSV, checks two pairs of columns:
      - GM(FCC_A1)   --> GM(FCC_A1#1)
      - HM(FCC_A1)   --> HM(FCC_A1#1)
    and where the target column (#1) is missing and the source column is present,
    moves (copies) the source value into the target column.

    Writes the modified DataFrame to 'output_csv'.
    """
    df = pd.read_csv(input_csv)

    # 1) GM(FCC_A1) -> GM(FCC_A1#1) where GM(FCC_A1#1) is empty but GM(FCC_A1) is not
    gm_mask = df['GM(FCC_A1)'].notna() & df['GM(FCC_A1#1)'].isna()
    df.loc[gm_mask, 'GM(FCC_A1#1)'] = df.loc[gm_mask, 'GM(FCC_A1)']

    # 2) HM(FCC_A1) -> HM(FCC_A1#1) where HM(FCC_A1#1) is empty but HM(FCC_A1) is not
    hm_mask = df['HM(FCC_A1)'].notna() & df['HM(FCC_A1#1)'].isna()
    df.loc[hm_mask, 'HM(FCC_A1#1)'] = df.loc[hm_mask, 'HM(FCC_A1)']

    # Now remove the original columns used for summation
    df.drop(columns=['GM(FCC_A1)', 'HM(FCC_A1)'], inplace=True, errors='ignore')

    df.rename(columns={'GM(FCC_A1#1)': 'G_RT_FCC', 'HM(FCC_A1#1)': 'H_RT_FCC'},inplace=True)

    df.to_csv(output_csv, index=False)

import pandas as pd

def sum_phase_fractions(input_csv, output_csv):
    df = pd.read_csv(input_csv)

    # Define sets of columns
    columns_fcc = ['FCC_A1', 'FCC_A1#1', 'FCC_A1_AUTO#2']
    columns_bcc = ['BCC_A2', 'BCC_A2#1', 'BCC_A2_AUTO#2', 'CBCC_A12', 'CBCC_A12#1']

    # 1) For each needed column, ensure it exists; if not, create it filled with 0
    for col in columns_fcc + columns_bcc:
        if col not in df.columns:
            df[col] = 0

    # 2) Convert each of these columns to numeric and fill NaNs with 0
    for col in columns_fcc + columns_bcc:
        df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)

    # 3) Sum across each group of columns
    df['phase_fraction_FCC'] = df[columns_fcc].sum(axis=1)
    df['phase_fraction_BCC'] = df[columns_bcc].sum(axis=1)

    # Optionally drop the original columns
    df.drop(columns=columns_fcc + columns_bcc, inplace=True, errors='ignore')

    df.to_csv(output_csv, index=False, float_format='%.3f')


if __name__ == "__main__":
    skipStep1 = True
    skipStep2 = False
    skipStep3 = False

    # Step 1: Align rows in B.csv to match A.csv by columns A..J
    csvA_path = "./df_298_cleaned_el_melting_point - df_298_cleaned.csv"
    csvB_path = "./rebuilt_using_calphad_data - output.csv"
    #outputB_aligned_path = "./reordered_and_aligned_to_original.csv"
    outputB_aligned_path = "./alcrcofeni-data_with_phases_and_calcs-2k.csv"

    if not skipStep1:
      align_csv_by_key(csvA_path, csvB_path, outputB_aligned_path)
      print(f"Aligned CSV written to '{outputB_aligned_path}'.")

    if not skipStep2:
      # 2. Now sum the phase-fraction columns
      outputB_with_phases_summed_path = "_with_phase_fractions_summed.csv"
      sum_phase_fractions(outputB_aligned_path, outputB_with_phases_summed_path)
      print(f"Added phase-fraction columns in '{outputB_with_phases_summed_path}'.")

    if not skipStep3:
      # 3. Finally, merge the GM(FCC_A1#1) with the GM(FCC_A1) and the HM(FCC_A1#1) with the HM(FCC_A1) columns
      outputB_gm_hm_filled_path = "_with_gm_and_hm.csv"
      fill_gm_hm_columns(outputB_with_phases_summed_path, outputB_gm_hm_filled_path)
      print(f"Filled GM/HM columns in '{outputB_gm_hm_filled_path}'.")