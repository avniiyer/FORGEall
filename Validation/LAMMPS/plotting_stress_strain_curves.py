# -*- coding: utf-8 -*-
"""Plotting stress-strain curves

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-WNUOrkPftvgdRBFSzzV7BzSQJRG8kiX
"""

import numpy as np
import matplotlib.pyplot as plt

# Load stress-strain data
strain, stress = np.loadtxt("my_hea_stress_strain.txt", usecols=(0, 1), unpack=True)


# Create figure with larger axis ranges
plt.figure(figsize=(10, 6))  # Adjust figure size
plt.scatter(strain, stress, color='blue', marker='o', s=50)


# ✅ Expand the X and Y axis ranges
plt.xlim(0, max(strain) * 1.2)  # Expand x-axis range by 20%
plt.ylim(min(stress) * 1.2, 0)  # Expand y-axis range by 20%

# Labels and Title
plt.xlabel("Strain", fontsize=14)
plt.ylabel("Stress (GPa)", fontsize=14)
plt.title("Stress-Strain Curve for HEA", fontsize=16)

# Improve readability
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.legend(fontsize=12)
plt.grid(True)

# Show the plot
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import make_interp_spline  # For spline interpolation

# Load stress-strain data
strain, stress = np.loadtxt("my_hea_stress_strain.txt", usecols=(0, 1), unpack=True)

# Create figure with larger axis ranges
plt.figure(figsize=(10, 6))

# Plot the original data points
plt.scatter(strain, stress, color='blue', marker='o', s=50, label='Data Points')

# ---- Smooth (curved) line through the data using spline interpolation ----
# 1. Sort data by strain (important for spline interpolation if data isn't already sorted)
sorted_indices = np.argsort(strain)
strain_sorted = strain[sorted_indices]
stress_sorted = stress[sorted_indices]

# 2. Create spline representation of your data
spline = make_interp_spline(strain_sorted, stress_sorted, k=2)  # k=3 gives a cubic spline

# 3. Generate a dense range of strain values and interpolate
strain_fine = np.linspace(strain.min(), strain.max(), 300)  # 300 points
stress_smooth = spline(strain_fine)

coefs = np.polyfit(strain, stress, deg=3)  # e.g., a cubic polynomial
poly = np.poly1d(coefs)
strain_fine = np.linspace(strain.min(), strain.max(), 300)
stress_smooth = poly(strain_fine)
plt.plot(strain_fine, stress_smooth, 'r-', label='Polynomial Fit')

# Expand the X and Y axis ranges
plt.xlim(0, max(strain) * 1.2)  # Expand x-axis range by 20%

# If your stress is compressive (negative values), you might keep y-limits as is.
# Otherwise, you might want to flip it to something like: plt.ylim(0, max(stress)*1.2).
# Here, I'm keeping your original logic, but feel free to adjust:
plt.ylim(min(stress) * 1.2, 0)

# Labels and Title
plt.xlabel("Strain", fontsize=14)
plt.ylabel("Stress (GPa)", fontsize=14)
plt.title("Stress-Strain Curve for HEA", fontsize=16)

# Improve readability
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.legend(fontsize=12)
plt.grid(True)

# Show the plot
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# File containing the data
file_path = "msd_output.txt"  # Change this if your file has a different name

# Initialize lists to store timestep and msad values
timesteps = []
msad_values = []

# Read the data
with open(file_path, "r") as file:
    lines = file.readlines()

    current_timestep = None
    current_msad = None

    for line in lines:
        parts = line.split()

        # Detect new timestep entry
        if len(parts) == 2 and parts[0].isdigit() and parts[1].isdigit():
            if current_timestep is not None and current_msad is not None:
                timesteps.append(current_timestep)
                msad_values.append(current_msad)  # Save only the last c_msad value per timestep

            current_timestep = int(parts[0])  # Store new timestep
            current_msad = None  # Reset msad tracking

        # Otherwise, it's an msad value row
        elif len(parts) == 2 and parts[0].isdigit():
            current_msad = float(parts[1])  # Keep updating to the last c_msad of the block

    # Ensure the last block gets saved
    if current_timestep is not None and current_msad is not None:
        timesteps.append(current_timestep)
        msad_values.append(current_msad)

# Compute the square root of MSAD values
sqrt_msad = np.sqrt(msad_values)

print(sqrt_msad)

# ✅ Expand the X and Y axis ranges
plt.xlim(0, max(timesteps))  # Expand x-axis range by 20%
plt.ylim(0, max(sqrt_msad))  # Expand y-axis range by 20%

# Plot the results
plt.scatter(timesteps, sqrt_msad)
plt.xlabel("Timestep")
plt.ylabel("sqrt(MSAD)")
plt.title("Square Root of Mean Squared Atomic Displacement over Time")
plt.grid(True)
plt.show()

sum = 0
for i in range(len(sqrt_msad)):
    sum += sqrt_msad[i]
average_msad = sum/len(sqrt_msad)
print(average_msad)